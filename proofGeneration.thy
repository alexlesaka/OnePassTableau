theory proofGeneration
  imports TTC_Solvers

begin

(* 
Please, follow the instructions to uncomment lemmas for testing the three solvers
defined in the file TTC_Solvers.thy 
WARNING: The automatically generated file "Proof.txt" will be generated in the directory
that your Isabelle IDE uses, that could be the Isabelle2018 home.
*)

(* Test the basic solver in TTC_Solvers proving (uncommenting) the following lemma *)

(*
lemma runningExample_proof: "S @ [\<circle>(\<diamond>(V ''a''))] \<turnstile> F"    
  apply solver
  done
*)

(* Test the solver that generates the big-step proof, 
proving (uncommenting) the following lemma *)

(*
lemma runningExample_bigStep_proof_generation: "S @ [\<circle>(\<diamond>(V ''a''))] \<turnstile> F" 
(* Generates a file Proof.txt, with the big-step proof *)
  apply solver_print_Big_Step
  done
*)

(* Uncomment the following proof (in the paper), or cut-and-paste the one in Proof.txt, 
   to check the generated big-step proof*)
(*
lemma runningExample_bigStep_proof: "S @ [\<circle>(\<diamond>(V ''a''))] \<turnstile> F" 
apply (rule TTC_Interchange, simp add: S_def TR_def T1_def T2_def T3_def T4_def Init_def) (*1*)
apply one_step_solver                                                                     (*2*)
apply (all \<open>rule TTC_Next_State\<close>; simp)                                                   (*3*)
apply (fold T1_def T2_def T3_def T4_def)                                                  (*4*)
apply (simp add: T1_def T2_def T3_def T4_def Init_def)                                    (*5*)
apply one_step_solver                                                                     (*6*)
apply (all \<open>rule TTC_Next_State\<close>; simp)                                                   (*7*)
apply (fold T1_def T2_def T3_def T4_def)                                                  (*8*)
apply (simp add: T1_def T2_def T3_def T4_def Init_def)                                    (*9*)
apply one_step_solver                                                                     (*10*)
apply (all \<open>rule TTC_Next_State\<close>; simp)                                                   (*11*)
apply (simp add: T1_def T2_def T3_def T4_def Init_def)                                    (*12*)
apply one_step_solver                                                                     (*13*)
apply (all \<open>rule TTC_Next_State\<close>; simp)                                                   (*14*)
apply (fold T1_def T2_def T3_def T4_def)                                                  (*15*)
apply (simp add: T1_def T2_def T3_def T4_def Init_def)                                    (*16*)
apply one_step_solver                                                                     (*17*)
  done
*)

(* Test the solver that generates the small-step proof, 
proving (uncommenting) the following lemma *)

(*
lemma runningExample_smallStep_proof_generation: "S @ [\<circle>(\<diamond>(V ''a''))] \<turnstile> F" 
(* Generates a file Proof.txt, with the bellow small-step proof. 
   WARNING: If you have in Proof.txt a previously generate proof,
            the new one is appended to it. Our recommendation is
            to remove the previous file.*)
apply solver_print_Small_Step
    done
*)

(* Uncomment the following, or cut-and-paste the generated Proof.txt, 
to check the generated small-step proof*)

(*
  apply (rule TTC_Interchange, simp add: S_def TR_def T1_def T2_def T3_def T4_def Init_def)
(* step *)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
defer
apply (rule TTC_Or; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
defer
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''c'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
defer
apply (rule TTC_Or; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
defer
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''b'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''a'')" in TTC_Ctd1; simp)
apply (tactic {* distinct_subgoals_tac *})
apply (all \<open>rule TTC_Next_State\<close>; simp)
apply (fold T1_def T2_def T3_def T4_def)
apply (simp add: T1_def T2_def T3_def T4_def)
(* step *)
apply (rule TTC_Evt_Plus; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule_tac phi = "(V ''b'')" in TTC_Ctd1; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
defer
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
defer
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
defer
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''c'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule_tac phi = "(V ''b'')" in TTC_Ctd1; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
defer
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
defer
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''b'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule_tac phi = "(V ''b'')" in TTC_Ctd1; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''a'')" in TTC_Ctd1; simp)
apply (tactic {* distinct_subgoals_tac *})
apply (all \<open>rule TTC_Next_State\<close>; simp)
apply (fold T1_def T2_def T3_def T4_def)
apply (simp add: T1_def T2_def T3_def T4_def)
(* step *)
apply (rule TTC_U_Sel; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_Or; simp)
apply (rule_tac phi = "(V ''b'')" in TTC_Ctd1; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule_tac phi = "(V ''c'')" in TTC_Ctd1; simp)
apply (rule_tac phi = "(V ''d'')" in TTC_Ctd1; simp)
apply (tactic {* distinct_subgoals_tac *})
apply (all \<open>rule TTC_Next_State\<close>; simp)
apply (simp add: T1_def T2_def T3_def T4_def)
(* step *)
apply (rule TTC_U_Sel; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule_tac phi = "(V ''c'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
defer
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
defer
apply (rule TTC_Or; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
defer
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
defer
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''b'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule_tac phi = "(V ''c'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''a'')" in TTC_Ctd1; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule_tac phi = "(V ''c'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
defer
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
defer
apply (rule TTC_Or; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
defer
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
defer
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''b'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Alw; simp)
apply (rule TTC_Imp; simp)
apply (rule_tac phi = "(V ''c'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule TTC_And; simp)
apply (rule_tac phi = "\<circle>(V ''a'')" in TTC_Ctd1; simp)
apply (rule_tac phi = "(V ''d'')" in TTC_Ctd1; simp)
apply (tactic {* distinct_subgoals_tac *})
apply (all \<open>rule TTC_Next_State\<close>; simp)
apply (fold T1_def T2_def T3_def T4_def)
apply (simp add: T1_def T2_def T3_def T4_def)
(* step *)
apply (rule TTC_U_Sel; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule TTC_And; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_Or; simp)
apply (rule_tac phi = "(V ''b'')" in TTC_Ctd1; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule_tac phi = "(V ''c'')" in TTC_Ctd1; simp)
apply (rule TTC_Or; simp)
apply (rule TTC_Or; simp)
apply (rule_tac phi = "(V ''b'')" in TTC_Ctd1; simp)
apply (rule_tac phi = "(V ''a'')" in TTC_Ctd1; simp)
apply (rule_tac phi = "(V ''c'')" in TTC_Ctd1; simp)
apply (rule_tac phi = "(V ''d'')" in TTC_Ctd1; simp)
apply (rule_tac phi = "(V ''d'')" in TTC_Ctd1; simp)
apply (tactic {* distinct_subgoals_tac *})
  done
*)

end
